{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"telegram-webapp-auth","text":"<p>This Python package implements Telegram Mini Apps authentication algorithms. It is designed to be simple and easy to use, providing a straightforward way to authenticate users in Telegram Mini Apps.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Easy to use: The package is designed to be simple and intuitive, making it easy to integrate into your Telegram Mini App.</li> <li>Secure: It implements the authentication algorithms as described in the Telegram Mini Apps documentation, ensuring that your app's authentication is secure.</li> <li>Lightweight: The package is small, making it easy to include in your project without adding unnecessary bloat.</li> <li>Type hints: The package is fully typed, providing better code completion and type checking in your IDE.</li> <li>Well-documented: The package comes with comprehensive documentation, making it easy to understand how to use it effectively.</li> <li>Tested: The package includes unit tests to ensure that it works correctly and reliably.</li> <li>Supports Python 3.9+: The package is compatible with Python 3.9 and later versions, ensuring that it works with modern Python environments.</li> <li>Open source: The package is open source and licensed under the MIT License, allowing you to use it freely in your projects.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or later</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install telegram-webapp-auth\n# or\npoetry add telegram-webapp-auth\n# or\nuv add telegram-webapp-auth\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>For detailed documentation, please visit the telegram-webapp-auth documentation.</p>"},{"location":"#license","title":"License","text":"<p><code>telegram-webapp-auth</code> is licensed under the MIT License.</p>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2024 Dmitry Vasiliev\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"guide/install/","title":"Installation","text":"<p>Get started with telegram-webapp-auth.</p>"},{"location":"guide/install/#setup","title":"Setup","text":""},{"location":"guide/install/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Make sure you have <code>`python</code> and <code>pip</code> properly installed in your system. <pre><code>python --version\npip --version\n</code></pre></p> </li> <li> <p>Create a new directory and move into it to follow along with this tutorial. <pre><code>mkdir learn-twa-auth &amp;&amp; cd learn-twa-auth\n</code></pre></p> </li> </ul>"},{"location":"guide/install/#installation","title":"Installation","text":"<ul> <li> <p>Create a virtual environment and activate it. <pre><code>python -m venv .venv &amp;&amp; source .venv/bin/activate\n</code></pre></p> </li> <li> <p>Install <code>telegram-webapp-auth</code> using <code>pip</code>: <pre><code>pip install --upgrade telegram-webapp-auth\n</code></pre></p> </li> </ul>"},{"location":"guide/examples/django/","title":"Django","text":""},{"location":"guide/examples/django/#using-with-django","title":"Using with Django","text":"<p>Let's create authorization middleware.</p> <p>Firstly, create variables in your <code>settings.py</code>: <pre><code>from telegram_webapp_auth.auth import generate_secret_key\n\n# other settings\n\nTELEGRAM_BOT_TOKEN = env.str('TELEGRAM_BOT_TOKEN')\nTELEGRAM_SECRET_KEY = generate_secret_key(TELEGRAM_BOT_TOKEN)\n</code></pre></p> <p>Then implement middleware:</p> <pre><code>from django.conf import settings\nfrom django.contrib.auth.models import User\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom telegram_webapp_auth.auth import TelegramAuthenticator\nfrom telegram_webapp_auth.errors import InvalidInitDataError\n\n\nclass TWAAuthorizationMiddleware:\n    def __init__(self, get_response) -&gt; None:\n        self.get_response = get_response\n        self._telegram_authenticator = TelegramAuthenticator(settings.TELEGRAM_SECRET_KEY)\n\n    def __call__(self, request: HttpRequest) -&gt; HttpResponse:\n        # Code to be executed for each request before\n        # the view (and later middleware) are called.\n        auth_cred = request.headers.get('Authorization')\n\n        try:\n            init_data = self._telegram_authenticator.validate(auth_cred)\n        except InvalidInitDataError:\n            # TODO: handle error\n            pass\n\n        if not init_data.user:\n            # TODO: handle error\n            pass\n\n        current_user = User.objects.filter(tg_id=init_data.user.id).first()\n        if not current_user:\n            # TODO: handle error\n            pass\n\n        request.user = current_user  # Associate current user with the request object\n\n        response = self.get_response(request)\n\n        # Code to be executed for each request/response after\n        # the view is called.\n\n        return response\n</code></pre> <p>To use <code>TWAAuthorizationMiddleware</code>, add it to your <code>MIDDLEWARE</code> setting in <code>settings.py</code>: <pre><code>MIDDLEWARE = [\n    # other middleware classes\n    'path.to.TWAAuthorizationMiddleware',\n]\n</code></pre></p>"},{"location":"guide/examples/fastapi/","title":"FastAPI","text":""},{"location":"guide/examples/fastapi/#using-with-fastapi","title":"Using with FastAPI","text":"<p>Let's create some useful stuff according to OAuth2 tutorial.</p> <p>File <code>auth.py</code>:</p> <pre><code>import http\n\nfrom fastapi import Depends\nfrom fastapi import HTTPException\nfrom fastapi.security.http import HTTPAuthorizationCredentials\nfrom fastapi.security.http import HTTPBase\n\nfrom telegram_webapp_auth.auth import TelegramAuthenticator\nfrom telegram_webapp_auth.auth import WebAppUser\nfrom telegram_webapp_auth.auth import generate_secret_key\nfrom telegram_webapp_auth.errors import InvalidInitDataError\n\nfrom .config import TelegramBotSettings  # Telegram Bot configuration\n\ntelegram_authentication_schema = HTTPBase()\n\n\ndef get_telegram_authenticator() -&gt; TelegramAuthenticator:\n    settings = TelegramBotSettings()\n    secret_key = generate_secret_key(settings.token)\n    return TelegramAuthenticator(secret_key)\n\n\ndef get_current_user(\n    auth_cred: HTTPAuthorizationCredentials = Depends(telegram_authentication_schema),\n    telegram_authenticator: TelegramAuthenticator = Depends(get_telegram_authenticator),\n) -&gt; WebAppUser:\n    try:\n        init_data = telegram_authenticator.validate(auth_cred.credentials)\n    except InvalidInitDataError:\n        raise HTTPException(\n            status_code=http.HTTPStatus.FORBIDDEN,\n            detail=\"Forbidden access.\",\n        )\n    except Exception:\n        raise HTTPException(\n            status_code=http.HTTPStatus.INTERNAL_SERVER_ERROR,\n            detail=\"Internal error.\",\n        )\n\n    if init_data.user is None:\n        raise HTTPException(\n            status_code=http.HTTPStatus.FORBIDDEN,\n            detail=\"Forbidden access.\",\n        )\n\n    return init_data.user\n</code></pre> <p>Finally, we can use it as usual.</p> <p>File <code>app.py</code>:</p> <pre><code>from fastapi import Depends\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\nfrom telegram_webapp_auth.auth import WebAppUser\n\nfrom .auth import get_current_user\n\napp = FastAPI()\n\n\nclass Message(BaseModel):\n    text: str\n\n\n@app.post(\"/message\")\nasync def send_message(\n    message: Message,\n    user: WebAppUser = Depends(get_current_user),\n):\n    \"\"\"\n    Some logic...\n    \"\"\"\n    ...\n</code></pre>"},{"location":"references/auth/","title":"Authorization","text":"<p>Telegram Web App Authenticator utilities.</p>"},{"location":"references/auth/#telegram_webapp_auth.auth.TelegramAuthenticator","title":"<code>TelegramAuthenticator</code>","text":"<p>Telegram Web App Authenticator.</p> Source code in <code>telegram_webapp_auth/auth.py</code> <pre><code>class TelegramAuthenticator:\n    \"\"\"Telegram Web App Authenticator.\"\"\"\n\n    def __init__(self, secret: bytes) -&gt; None:\n        \"\"\"Initialize the authenticator with a secret key.\n\n        Args:\n            secret: secret key generated from the Telegram Bot Token\n        \"\"\"\n        self._secret = secret\n\n    @staticmethod\n    def __parse_init_data(data: str) -&gt; dict:\n        \"\"\"Convert init_data string into dictionary.\n\n        Args:\n            data: the query string passed by the webapp\n        \"\"\"\n        if not data:\n            raise InvalidInitDataError(\"Init Data cannot be empty\")\n\n        parsed_data = parse_qs(data)\n        return {key: value[0] for key, value in parsed_data.items()}\n\n    @staticmethod\n    def __parse_json(data: str) -&gt; dict:\n        \"\"\"Convert JSON string value from WebAppInitData to Python dictionary.\n\n        Links:\n            https://core.telegram.org/bots/webapps#webappinitdata\n\n        Raises:\n            InvalidInitDataError\n        \"\"\"\n        try:\n            return json.loads(unquote(data))\n        except JSONDecodeError:\n            raise InvalidInitDataError(\"Cannot decode init data\")\n\n    def _validate(self, hash_: str, init_data: str) -&gt; bool:\n        \"\"\"Validates the data received from the Telegram web app, using the method from Telegram documentation.\n\n        Links:\n            https://core.telegram.org/bots/webapps#validating-data-received-via-the-mini-app\n\n        Args:\n            hash_: hash from init data\n            init_data: init data from webapp\n\n        Returns:\n            bool: Validation result\n        \"\"\"\n        init_data_bytes = init_data.encode(\"utf-8\")\n        client_hash = hmac.new(self._secret, init_data_bytes, hashlib.sha256).hexdigest()\n        return hmac.compare_digest(client_hash, hash_)\n\n    @staticmethod\n    def __ed25519_verify(\n        public_key: Ed25519PublicKey,\n        signature: bytes,\n        message: bytes,\n    ) -&gt; bool:\n        \"\"\"Verify the Ed25519 signature of the message using the public key.\n\n        Args:\n            public_key: public key\n            signature: signature\n            message: original message in bytes format\n\n        Returns:\n            bool: True if the signature is valid, False otherwise\n        \"\"\"\n        try:\n            public_key.verify(signature, message)\n            return True\n        except InvalidSignature:\n            return False\n\n    @staticmethod\n    def _check_expiry(auth_date: typing.Optional[str], expr_in: typing.Optional[timedelta]):\n        \"\"\"Check if the auth_date is present and not expired.\"\"\"\n        if not auth_date:\n            raise InvalidInitDataError(\"Init data does not contain auth_date\")\n\n        try:\n            auth_dt = datetime.fromtimestamp(float(auth_date), tz=timezone.utc)\n        except ValueError:\n            raise InvalidInitDataError(\"Invalid auth_date\")\n\n        if expr_in:\n            now = datetime.now(tz=timezone.utc)\n            if now - auth_dt &gt; expr_in:\n                raise ExpiredInitDataError\n\n    @staticmethod\n    def __decode_signature(val: str):\n        \"\"\"Decode a base64-encoded signature, appending padding if necessary.\n\n        :param val: A base64-encoded string.\n        :return: Decoded signature as bytes.\n        \"\"\"\n        # Add padding if the length is not a multiple of 4\n        padded_v = val + \"=\" * ((4 - len(val) % 4) % 4)\n\n        # Decode the Base64 string\n        try:\n            signature = base64.urlsafe_b64decode(padded_v)\n            return signature\n        except Exception as err:\n            raise InvalidInitDataError(f\"An error occurred during decoding: {err}\")\n\n    def __serialize_init_data(self, init_data_dict: typing.Dict[str, typing.Any]) -&gt; WebAppInitData:\n        \"\"\"Serialize the init data dictionary into WebAppInitData object.\n\n        Args:\n            init_data_dict: the init data dictionary\n\n        Returns:\n            WebAppInitData: the serialized WebAppInitData object\n        \"\"\"\n        user_data = init_data_dict.get(\"user\")\n        if user_data:\n            user_data = self.__parse_json(user_data)\n            init_data_dict[\"user\"] = WebAppUser(**user_data)\n        else:\n            init_data_dict[\"user\"] = None\n\n        chat_data = init_data_dict.get(\"chat\")\n        if chat_data:\n            chat_data = self.__parse_json(chat_data)\n            init_data_dict[\"chat\"] = WebAppChat(**chat_data)\n        else:\n            init_data_dict[\"chat\"] = None\n\n        receiver_data = init_data_dict.get(\"receiver\")\n        if receiver_data:\n            receiver_data = self.__parse_json(receiver_data)\n            init_data_dict[\"receiver\"] = WebAppUser(**receiver_data)\n        else:\n            init_data_dict[\"receiver\"] = None\n\n        return WebAppInitData(**init_data_dict)\n\n    def validate_third_party(\n        self,\n        init_data: str,\n        bot_id: int,\n        expr_in: typing.Optional[timedelta] = None,\n        is_test: bool = False,\n    ) -&gt; WebAppInitData:\n        \"\"\"Validates the data for Third-Party Use, using the method from Telegram documentation.\n\n        Links:\n            https://core.telegram.org/bots/webapps#validating-data-for-third-party-use\n\n        Args:\n            init_data: init data from mini app\n            bot_id: Telegram Bot ID\n            expr_in: time delta to check if the token is expired\n            is_test: true if the init data was issued in Telegram production environment\n\n        Returns:\n            WebAppInitData: parsed init a data object\n\n        Raises:\n            InvalidInitDataError: if the init data is invalid\n            ExpiredInitDataError: if the init data is expired\n        \"\"\"\n        init_data = unquote(init_data)\n        init_data_dict = self.__parse_init_data(init_data)\n        data_check_string = \"\\n\".join(\n            f\"{key}={val}\"\n            for key, val in sorted(init_data_dict.items(), key=lambda item: item[0])\n            if key != \"hash\" and key != \"signature\"\n        )\n        data_check_string = f\"{bot_id}:WebAppData\\n{data_check_string}\"\n\n        auth_date = init_data_dict.get(\"auth_date\")\n        self._check_expiry(auth_date, expr_in)\n\n        signature = init_data_dict.get(\"signature\")\n        if not signature:\n            raise InvalidInitDataError(\"Init data does not contain signature\")\n\n        signature = signature.strip()\n\n        if is_test:\n            public_key = TEST_PUBLIC_KEY\n        else:\n            public_key = PROD_PUBLIC_KEY\n\n        signature_bytes = self.__decode_signature(signature)\n        data_check_string_bytes = data_check_string.encode(\"utf-8\")\n        if not self.__ed25519_verify(public_key, signature_bytes, data_check_string_bytes):\n            raise InvalidInitDataError(\"Invalid data\")\n\n        return self.__serialize_init_data(init_data_dict)\n\n    def validate(\n        self,\n        init_data: str,\n        expr_in: typing.Optional[timedelta] = None,\n    ) -&gt; WebAppInitData:\n        \"\"\"Validates the data received via the Mini App. Returns a parsed init data object if is valid.\n\n        Links:\n            https://core.telegram.org/bots/webapps#validating-data-received-via-the-mini-app\n\n        Args:\n            init_data: init data from mini app\n            expr_in: time delta to check if the token is expired\n\n        Returns:\n            WebAppInitData: parsed init a data object\n\n        Raises:\n            InvalidInitDataError: if the init data is invalid\n            ExpiredInitDataError: if the init data is expired\n        \"\"\"\n        init_data = unquote(init_data)\n        init_data_dict = self.__parse_init_data(init_data)\n        data_check_string = \"\\n\".join(\n            f\"{key}={val}\" for key, val in sorted(init_data_dict.items(), key=lambda item: item[0]) if key != \"hash\"\n        )\n        hash_ = init_data_dict.get(\"hash\")\n        if not hash_:\n            raise InvalidInitDataError(\"Init data does not contain hash\")\n\n        auth_date = init_data_dict.get(\"auth_date\")\n        self._check_expiry(auth_date, expr_in)\n\n        hash_ = hash_.strip()\n        if not self._validate(hash_, data_check_string):\n            raise InvalidInitDataError(\"Invalid data\")\n\n        return self.__serialize_init_data(init_data_dict)\n</code></pre>"},{"location":"references/auth/#telegram_webapp_auth.auth.TelegramAuthenticator.__decode_signature","title":"<code>__decode_signature(val)</code>  <code>staticmethod</code>","text":"<p>Decode a base64-encoded signature, appending padding if necessary.</p> <p>:param val: A base64-encoded string. :return: Decoded signature as bytes.</p> Source code in <code>telegram_webapp_auth/auth.py</code> <pre><code>@staticmethod\ndef __decode_signature(val: str):\n    \"\"\"Decode a base64-encoded signature, appending padding if necessary.\n\n    :param val: A base64-encoded string.\n    :return: Decoded signature as bytes.\n    \"\"\"\n    # Add padding if the length is not a multiple of 4\n    padded_v = val + \"=\" * ((4 - len(val) % 4) % 4)\n\n    # Decode the Base64 string\n    try:\n        signature = base64.urlsafe_b64decode(padded_v)\n        return signature\n    except Exception as err:\n        raise InvalidInitDataError(f\"An error occurred during decoding: {err}\")\n</code></pre>"},{"location":"references/auth/#telegram_webapp_auth.auth.TelegramAuthenticator.__ed25519_verify","title":"<code>__ed25519_verify(public_key, signature, message)</code>  <code>staticmethod</code>","text":"<p>Verify the Ed25519 signature of the message using the public key.</p> <p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>Ed25519PublicKey</code> <p>public key</p> required <code>signature</code> <code>bytes</code> <p>signature</p> required <code>message</code> <code>bytes</code> <p>original message in bytes format</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the signature is valid, False otherwise</p> Source code in <code>telegram_webapp_auth/auth.py</code> <pre><code>@staticmethod\ndef __ed25519_verify(\n    public_key: Ed25519PublicKey,\n    signature: bytes,\n    message: bytes,\n) -&gt; bool:\n    \"\"\"Verify the Ed25519 signature of the message using the public key.\n\n    Args:\n        public_key: public key\n        signature: signature\n        message: original message in bytes format\n\n    Returns:\n        bool: True if the signature is valid, False otherwise\n    \"\"\"\n    try:\n        public_key.verify(signature, message)\n        return True\n    except InvalidSignature:\n        return False\n</code></pre>"},{"location":"references/auth/#telegram_webapp_auth.auth.TelegramAuthenticator.__init__","title":"<code>__init__(secret)</code>","text":"<p>Initialize the authenticator with a secret key.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>bytes</code> <p>secret key generated from the Telegram Bot Token</p> required Source code in <code>telegram_webapp_auth/auth.py</code> <pre><code>def __init__(self, secret: bytes) -&gt; None:\n    \"\"\"Initialize the authenticator with a secret key.\n\n    Args:\n        secret: secret key generated from the Telegram Bot Token\n    \"\"\"\n    self._secret = secret\n</code></pre>"},{"location":"references/auth/#telegram_webapp_auth.auth.TelegramAuthenticator.__parse_init_data","title":"<code>__parse_init_data(data)</code>  <code>staticmethod</code>","text":"<p>Convert init_data string into dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>the query string passed by the webapp</p> required Source code in <code>telegram_webapp_auth/auth.py</code> <pre><code>@staticmethod\ndef __parse_init_data(data: str) -&gt; dict:\n    \"\"\"Convert init_data string into dictionary.\n\n    Args:\n        data: the query string passed by the webapp\n    \"\"\"\n    if not data:\n        raise InvalidInitDataError(\"Init Data cannot be empty\")\n\n    parsed_data = parse_qs(data)\n    return {key: value[0] for key, value in parsed_data.items()}\n</code></pre>"},{"location":"references/auth/#telegram_webapp_auth.auth.TelegramAuthenticator.__parse_json","title":"<code>__parse_json(data)</code>  <code>staticmethod</code>","text":"<p>Convert JSON string value from WebAppInitData to Python dictionary.</p> Links <p>https://core.telegram.org/bots/webapps#webappinitdata</p> Source code in <code>telegram_webapp_auth/auth.py</code> <pre><code>@staticmethod\ndef __parse_json(data: str) -&gt; dict:\n    \"\"\"Convert JSON string value from WebAppInitData to Python dictionary.\n\n    Links:\n        https://core.telegram.org/bots/webapps#webappinitdata\n\n    Raises:\n        InvalidInitDataError\n    \"\"\"\n    try:\n        return json.loads(unquote(data))\n    except JSONDecodeError:\n        raise InvalidInitDataError(\"Cannot decode init data\")\n</code></pre>"},{"location":"references/auth/#telegram_webapp_auth.auth.TelegramAuthenticator.__serialize_init_data","title":"<code>__serialize_init_data(init_data_dict)</code>","text":"<p>Serialize the init data dictionary into WebAppInitData object.</p> <p>Parameters:</p> Name Type Description Default <code>init_data_dict</code> <code>Dict[str, Any]</code> <p>the init data dictionary</p> required <p>Returns:</p> Name Type Description <code>WebAppInitData</code> <code>WebAppInitData</code> <p>the serialized WebAppInitData object</p> Source code in <code>telegram_webapp_auth/auth.py</code> <pre><code>def __serialize_init_data(self, init_data_dict: typing.Dict[str, typing.Any]) -&gt; WebAppInitData:\n    \"\"\"Serialize the init data dictionary into WebAppInitData object.\n\n    Args:\n        init_data_dict: the init data dictionary\n\n    Returns:\n        WebAppInitData: the serialized WebAppInitData object\n    \"\"\"\n    user_data = init_data_dict.get(\"user\")\n    if user_data:\n        user_data = self.__parse_json(user_data)\n        init_data_dict[\"user\"] = WebAppUser(**user_data)\n    else:\n        init_data_dict[\"user\"] = None\n\n    chat_data = init_data_dict.get(\"chat\")\n    if chat_data:\n        chat_data = self.__parse_json(chat_data)\n        init_data_dict[\"chat\"] = WebAppChat(**chat_data)\n    else:\n        init_data_dict[\"chat\"] = None\n\n    receiver_data = init_data_dict.get(\"receiver\")\n    if receiver_data:\n        receiver_data = self.__parse_json(receiver_data)\n        init_data_dict[\"receiver\"] = WebAppUser(**receiver_data)\n    else:\n        init_data_dict[\"receiver\"] = None\n\n    return WebAppInitData(**init_data_dict)\n</code></pre>"},{"location":"references/auth/#telegram_webapp_auth.auth.TelegramAuthenticator.validate","title":"<code>validate(init_data, expr_in=None)</code>","text":"<p>Validates the data received via the Mini App. Returns a parsed init data object if is valid.</p> Links <p>https://core.telegram.org/bots/webapps#validating-data-received-via-the-mini-app</p> <p>Parameters:</p> Name Type Description Default <code>init_data</code> <code>str</code> <p>init data from mini app</p> required <code>expr_in</code> <code>Optional[timedelta]</code> <p>time delta to check if the token is expired</p> <code>None</code> <p>Returns:</p> Name Type Description <code>WebAppInitData</code> <code>WebAppInitData</code> <p>parsed init a data object</p> <p>Raises:</p> Type Description <code>InvalidInitDataError</code> <p>if the init data is invalid</p> <code>ExpiredInitDataError</code> <p>if the init data is expired</p> Source code in <code>telegram_webapp_auth/auth.py</code> <pre><code>def validate(\n    self,\n    init_data: str,\n    expr_in: typing.Optional[timedelta] = None,\n) -&gt; WebAppInitData:\n    \"\"\"Validates the data received via the Mini App. Returns a parsed init data object if is valid.\n\n    Links:\n        https://core.telegram.org/bots/webapps#validating-data-received-via-the-mini-app\n\n    Args:\n        init_data: init data from mini app\n        expr_in: time delta to check if the token is expired\n\n    Returns:\n        WebAppInitData: parsed init a data object\n\n    Raises:\n        InvalidInitDataError: if the init data is invalid\n        ExpiredInitDataError: if the init data is expired\n    \"\"\"\n    init_data = unquote(init_data)\n    init_data_dict = self.__parse_init_data(init_data)\n    data_check_string = \"\\n\".join(\n        f\"{key}={val}\" for key, val in sorted(init_data_dict.items(), key=lambda item: item[0]) if key != \"hash\"\n    )\n    hash_ = init_data_dict.get(\"hash\")\n    if not hash_:\n        raise InvalidInitDataError(\"Init data does not contain hash\")\n\n    auth_date = init_data_dict.get(\"auth_date\")\n    self._check_expiry(auth_date, expr_in)\n\n    hash_ = hash_.strip()\n    if not self._validate(hash_, data_check_string):\n        raise InvalidInitDataError(\"Invalid data\")\n\n    return self.__serialize_init_data(init_data_dict)\n</code></pre>"},{"location":"references/auth/#telegram_webapp_auth.auth.TelegramAuthenticator.validate_third_party","title":"<code>validate_third_party(init_data, bot_id, expr_in=None, is_test=False)</code>","text":"<p>Validates the data for Third-Party Use, using the method from Telegram documentation.</p> Links <p>https://core.telegram.org/bots/webapps#validating-data-for-third-party-use</p> <p>Parameters:</p> Name Type Description Default <code>init_data</code> <code>str</code> <p>init data from mini app</p> required <code>bot_id</code> <code>int</code> <p>Telegram Bot ID</p> required <code>expr_in</code> <code>Optional[timedelta]</code> <p>time delta to check if the token is expired</p> <code>None</code> <code>is_test</code> <code>bool</code> <p>true if the init data was issued in Telegram production environment</p> <code>False</code> <p>Returns:</p> Name Type Description <code>WebAppInitData</code> <code>WebAppInitData</code> <p>parsed init a data object</p> <p>Raises:</p> Type Description <code>InvalidInitDataError</code> <p>if the init data is invalid</p> <code>ExpiredInitDataError</code> <p>if the init data is expired</p> Source code in <code>telegram_webapp_auth/auth.py</code> <pre><code>def validate_third_party(\n    self,\n    init_data: str,\n    bot_id: int,\n    expr_in: typing.Optional[timedelta] = None,\n    is_test: bool = False,\n) -&gt; WebAppInitData:\n    \"\"\"Validates the data for Third-Party Use, using the method from Telegram documentation.\n\n    Links:\n        https://core.telegram.org/bots/webapps#validating-data-for-third-party-use\n\n    Args:\n        init_data: init data from mini app\n        bot_id: Telegram Bot ID\n        expr_in: time delta to check if the token is expired\n        is_test: true if the init data was issued in Telegram production environment\n\n    Returns:\n        WebAppInitData: parsed init a data object\n\n    Raises:\n        InvalidInitDataError: if the init data is invalid\n        ExpiredInitDataError: if the init data is expired\n    \"\"\"\n    init_data = unquote(init_data)\n    init_data_dict = self.__parse_init_data(init_data)\n    data_check_string = \"\\n\".join(\n        f\"{key}={val}\"\n        for key, val in sorted(init_data_dict.items(), key=lambda item: item[0])\n        if key != \"hash\" and key != \"signature\"\n    )\n    data_check_string = f\"{bot_id}:WebAppData\\n{data_check_string}\"\n\n    auth_date = init_data_dict.get(\"auth_date\")\n    self._check_expiry(auth_date, expr_in)\n\n    signature = init_data_dict.get(\"signature\")\n    if not signature:\n        raise InvalidInitDataError(\"Init data does not contain signature\")\n\n    signature = signature.strip()\n\n    if is_test:\n        public_key = TEST_PUBLIC_KEY\n    else:\n        public_key = PROD_PUBLIC_KEY\n\n    signature_bytes = self.__decode_signature(signature)\n    data_check_string_bytes = data_check_string.encode(\"utf-8\")\n    if not self.__ed25519_verify(public_key, signature_bytes, data_check_string_bytes):\n        raise InvalidInitDataError(\"Invalid data\")\n\n    return self.__serialize_init_data(init_data_dict)\n</code></pre>"},{"location":"references/auth/#telegram_webapp_auth.auth.generate_secret_key","title":"<code>generate_secret_key(token)</code>","text":"<p>Generates a secret key from a Telegram token.</p> Links <p>https://core.telegram.org/bots/webapps#validating-data-received-via-the-mini-app</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Telegram Bot Token</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>secret key</p> Source code in <code>telegram_webapp_auth/auth.py</code> <pre><code>def generate_secret_key(token: str) -&gt; bytes:\n    \"\"\"Generates a secret key from a Telegram token.\n\n    Links:\n        https://core.telegram.org/bots/webapps#validating-data-received-via-the-mini-app\n\n    Args:\n        token: Telegram Bot Token\n\n    Returns:\n        bytes: secret key\n    \"\"\"\n    base = \"WebAppData\".encode(\"utf-8\")\n    token_enc = token.encode(\"utf-8\")\n    return hmac.digest(base, token_enc, hashlib.sha256)\n</code></pre>"},{"location":"references/data/","title":"Data","text":"<p>This module contains data structures used in the Telegram Web Apps API.</p>"},{"location":"references/data/#telegram_webapp_auth.data.ChatType","title":"<code>ChatType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Represents the type of Telegram chat.</p> Source code in <code>telegram_webapp_auth/data.py</code> <pre><code>class ChatType(str, enum.Enum):\n    \"\"\"Represents the type of Telegram chat.\"\"\"\n\n    PRIVATE = \"private\"\n    GROUP = \"group\"\n    SUPERGROUP = \"supergroup\"\n    CHANNEL = \"channel\"\n</code></pre>"},{"location":"references/data/#telegram_webapp_auth.data.WebAppChat","title":"<code>WebAppChat</code>  <code>dataclass</code>","text":"<p>Represents a Telegram chat.</p> Links <p>https://core.telegram.org/bots/webapps#webappchat</p> Source code in <code>telegram_webapp_auth/data.py</code> <pre><code>@dataclasses.dataclass\nclass WebAppChat:\n    \"\"\"Represents a Telegram chat.\n\n    Links:\n        https://core.telegram.org/bots/webapps#webappchat\n    \"\"\"\n\n    id: int\n    type: ChatType\n    title: str\n    username: typing.Optional[str] = None\n    photo_url: typing.Optional[str] = None\n</code></pre>"},{"location":"references/data/#telegram_webapp_auth.data.WebAppInitData","title":"<code>WebAppInitData</code>  <code>dataclass</code>","text":"<p>Represents the data that the webapp receives from Telegram.</p> Links <p>https://core.telegram.org/bots/webapps#webappinitdata</p> Source code in <code>telegram_webapp_auth/data.py</code> <pre><code>@dataclasses.dataclass\nclass WebAppInitData:\n    \"\"\"Represents the data that the webapp receives from Telegram.\n\n    Links:\n        https://core.telegram.org/bots/webapps#webappinitdata\n    \"\"\"\n\n    auth_date: int\n    hash: str\n    signature: str\n    query_id: typing.Optional[str] = None\n    user: typing.Optional[WebAppUser] = None\n    receiver: typing.Optional[WebAppUser] = None\n    chat: typing.Optional[WebAppChat] = None\n    chat_type: typing.Optional[ChatType] = None\n    chat_instance: typing.Optional[str] = None\n    start_param: typing.Optional[str] = None\n    can_send_after: typing.Optional[int] = None\n</code></pre>"},{"location":"references/data/#telegram_webapp_auth.data.WebAppUser","title":"<code>WebAppUser</code>  <code>dataclass</code>","text":"<p>Represents a Telegram user.</p> Links <p>https://core.telegram.org/bots/webapps#webappuser</p> Source code in <code>telegram_webapp_auth/data.py</code> <pre><code>@dataclasses.dataclass\nclass WebAppUser:\n    \"\"\"Represents a Telegram user.\n\n    Links:\n        https://core.telegram.org/bots/webapps#webappuser\n    \"\"\"\n\n    id: int\n    first_name: str\n    is_bot: typing.Optional[bool] = None\n    last_name: typing.Optional[str] = None\n    username: typing.Optional[str] = None\n    language_code: typing.Optional[str] = None\n    is_premium: typing.Optional[bool] = None\n    added_to_attachment_menu: typing.Optional[bool] = None\n    allows_write_to_pm: typing.Optional[bool] = None\n    photo_url: typing.Optional[str] = None\n</code></pre>"},{"location":"references/errors/","title":"Errors","text":""},{"location":"references/errors/#telegram_webapp_auth.errors.BaseTWAError","title":"<code>BaseTWAError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all TWA-related exceptions.</p> Source code in <code>telegram_webapp_auth/errors.py</code> <pre><code>class BaseTWAError(Exception):\n    \"\"\"Base class for all TWA-related exceptions.\"\"\"\n\n    pass\n</code></pre>"},{"location":"references/errors/#telegram_webapp_auth.errors.ExpiredInitDataError","title":"<code>ExpiredInitDataError</code>","text":"<p>               Bases: <code>BaseTWAError</code></p> <p>Raised when the init data has expired.</p> Source code in <code>telegram_webapp_auth/errors.py</code> <pre><code>class ExpiredInitDataError(BaseTWAError):\n    \"\"\"Raised when the init data has expired.\"\"\"\n\n    pass\n</code></pre>"},{"location":"references/errors/#telegram_webapp_auth.errors.InvalidInitDataError","title":"<code>InvalidInitDataError</code>","text":"<p>               Bases: <code>BaseTWAError</code></p> <p>Raised when the init data is invalid.</p> Source code in <code>telegram_webapp_auth/errors.py</code> <pre><code>class InvalidInitDataError(BaseTWAError):\n    \"\"\"Raised when the init data is invalid.\"\"\"\n\n    pass\n</code></pre>"},{"location":"coverage/","title":"Coverage","text":""}]}